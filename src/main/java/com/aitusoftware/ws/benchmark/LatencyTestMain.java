/*
 * Copyright 2019-2020 Aitu Software Limited.
 *
 * https://aitusoftware.com
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * This Java source file was generated by the Gradle 'init' task.
 */

package com.aitusoftware.ws.benchmark;

import java.io.File;
import java.io.PrintStream;
import java.net.InetSocketAddress;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.Instant;
import java.util.Arrays;

import org.HdrHistogram.Histogram;
import org.agrona.SystemUtil;

public final class LatencyTestMain
{
    public static void main(final String[] args) throws Exception
    {
        SystemUtil.loadPropertiesFiles(args);
        final int clientCount = Integer.getInteger("babl.perf.client.count", 9);
        final int threadCount = Integer.getInteger("babl.perf.thread.count", 3);
        final int messagesPerSecond = Integer.getInteger("babl.perf.messages.per.second", 150);
        final int measurementIterations = Integer.getInteger("babl.perf.measurement.iterations", 4);
        final int warmUpIterations = Integer.getInteger("babl.perf.warmup.iterations", 2);
        final int messagesPerIteration = Integer.getInteger("babl.perf.messages.per.iteration", 600);
        final int payloadSize = Integer.getInteger("babl.perf.payload.size", 120);
        final String cpuListProperty = System.getProperty("babl.perf.client.cpu.list");

        final int[] cpuList;
        if (cpuListProperty == null || cpuListProperty.trim().length() == 0)
        {
            cpuList = new int[0];
        }
        else
        {
            cpuList = Arrays.stream(cpuListProperty.split(",")).mapToInt(Integer::parseInt).toArray();
        }
        if (cpuList.length != 0 && cpuList.length < threadCount)
        {
            throw new IllegalArgumentException(String.format(
              "Cannot run %d threads over %d cpus in %s", threadCount, cpuList.length, cpuListProperty));
        }
        final LatencyTestHarness harness = new LatencyTestHarness(
            clientCount, threadCount, messagesPerSecond,
            measurementIterations, warmUpIterations, messagesPerIteration, payloadSize, cpuList);
        final Histogram histogram = harness.runLatencyTest(parseAddress(args));

        final String label = System.getProperty("babl.perf.results.label", "latency-" + Instant.now());
        final String resultDir = System.getProperty("babl.perf.results.dir", System.getProperty("user.dir"));
        Files.createDirectories(Paths.get(resultDir));
        histogram.outputPercentileDistribution(new PrintStream(new File(resultDir, label + ".hgram")), 1D);
    }

    private static InetSocketAddress parseAddress(final String[] args)
    {
        if (args.length < 1)
        {
            throw new IllegalArgumentException("Supply <host:port>");
        }

        final String[] tokens = args[0].split(":");
        return new InetSocketAddress(tokens[0], Integer.parseInt(tokens[1]));
    }
}